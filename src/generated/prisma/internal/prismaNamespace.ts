
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.3.0
 * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
 */
export const prismaVersion: PrismaVersion = {
  client: "7.3.0",
  engine: "9d6ad21cbbceab97458517b147a6a09ff43aa735"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  Fields: 'Fields',
  Matches: 'Matches',
  Divisions: 'Divisions',
  UserData: 'UserData',
  SensitiveUserData: 'SensitiveUserData',
  Invites: 'Invites',
  VolleyBallTeams: 'VolleyBallTeams',
  Messages: 'Messages',
  ChatGroup: 'ChatGroup',
  PushDeviceTarget: 'PushDeviceTarget',
  LockFiles: 'LockFiles',
  PaymentIntents: 'PaymentIntents',
  Bills: 'Bills',
  BillPayments: 'BillPayments',
  RefundRequests: 'RefundRequests',
  StripeAccounts: 'StripeAccounts',
  Events: 'Events',
  Organizations: 'Organizations',
  Products: 'Products',
  Subscriptions: 'Subscriptions',
  TimeSlots: 'TimeSlots',
  LeagueScoringConfigs: 'LeagueScoringConfigs',
  Sports: 'Sports',
  TemplateDocuments: 'TemplateDocuments',
  SignedDocuments: 'SignedDocuments',
  ParentChildLinks: 'ParentChildLinks',
  EventRegistrations: 'EventRegistrations',
  AuthUser: 'AuthUser',
  File: 'File'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "fields" | "matches" | "divisions" | "userData" | "sensitiveUserData" | "invites" | "volleyBallTeams" | "messages" | "chatGroup" | "pushDeviceTarget" | "lockFiles" | "paymentIntents" | "bills" | "billPayments" | "refundRequests" | "stripeAccounts" | "events" | "organizations" | "products" | "subscriptions" | "timeSlots" | "leagueScoringConfigs" | "sports" | "templateDocuments" | "signedDocuments" | "parentChildLinks" | "eventRegistrations" | "authUser" | "file"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    Fields: {
      payload: Prisma.$FieldsPayload<ExtArgs>
      fields: Prisma.FieldsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FieldsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FieldsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldsPayload>
        }
        findFirst: {
          args: Prisma.FieldsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FieldsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldsPayload>
        }
        findMany: {
          args: Prisma.FieldsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldsPayload>[]
        }
        create: {
          args: Prisma.FieldsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldsPayload>
        }
        createMany: {
          args: Prisma.FieldsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FieldsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldsPayload>[]
        }
        delete: {
          args: Prisma.FieldsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldsPayload>
        }
        update: {
          args: Prisma.FieldsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldsPayload>
        }
        deleteMany: {
          args: Prisma.FieldsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FieldsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FieldsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldsPayload>[]
        }
        upsert: {
          args: Prisma.FieldsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FieldsPayload>
        }
        aggregate: {
          args: Prisma.FieldsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFields>
        }
        groupBy: {
          args: Prisma.FieldsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FieldsGroupByOutputType>[]
        }
        count: {
          args: Prisma.FieldsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FieldsCountAggregateOutputType> | number
        }
      }
    }
    Matches: {
      payload: Prisma.$MatchesPayload<ExtArgs>
      fields: Prisma.MatchesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MatchesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MatchesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchesPayload>
        }
        findFirst: {
          args: Prisma.MatchesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MatchesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchesPayload>
        }
        findMany: {
          args: Prisma.MatchesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchesPayload>[]
        }
        create: {
          args: Prisma.MatchesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchesPayload>
        }
        createMany: {
          args: Prisma.MatchesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MatchesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchesPayload>[]
        }
        delete: {
          args: Prisma.MatchesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchesPayload>
        }
        update: {
          args: Prisma.MatchesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchesPayload>
        }
        deleteMany: {
          args: Prisma.MatchesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MatchesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MatchesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchesPayload>[]
        }
        upsert: {
          args: Prisma.MatchesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MatchesPayload>
        }
        aggregate: {
          args: Prisma.MatchesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMatches>
        }
        groupBy: {
          args: Prisma.MatchesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MatchesGroupByOutputType>[]
        }
        count: {
          args: Prisma.MatchesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MatchesCountAggregateOutputType> | number
        }
      }
    }
    Divisions: {
      payload: Prisma.$DivisionsPayload<ExtArgs>
      fields: Prisma.DivisionsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DivisionsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DivisionsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DivisionsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DivisionsPayload>
        }
        findFirst: {
          args: Prisma.DivisionsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DivisionsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DivisionsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DivisionsPayload>
        }
        findMany: {
          args: Prisma.DivisionsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DivisionsPayload>[]
        }
        create: {
          args: Prisma.DivisionsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DivisionsPayload>
        }
        createMany: {
          args: Prisma.DivisionsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DivisionsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DivisionsPayload>[]
        }
        delete: {
          args: Prisma.DivisionsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DivisionsPayload>
        }
        update: {
          args: Prisma.DivisionsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DivisionsPayload>
        }
        deleteMany: {
          args: Prisma.DivisionsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DivisionsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DivisionsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DivisionsPayload>[]
        }
        upsert: {
          args: Prisma.DivisionsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DivisionsPayload>
        }
        aggregate: {
          args: Prisma.DivisionsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDivisions>
        }
        groupBy: {
          args: Prisma.DivisionsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DivisionsGroupByOutputType>[]
        }
        count: {
          args: Prisma.DivisionsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DivisionsCountAggregateOutputType> | number
        }
      }
    }
    UserData: {
      payload: Prisma.$UserDataPayload<ExtArgs>
      fields: Prisma.UserDataFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserDataFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserDataFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload>
        }
        findFirst: {
          args: Prisma.UserDataFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserDataFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload>
        }
        findMany: {
          args: Prisma.UserDataFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload>[]
        }
        create: {
          args: Prisma.UserDataCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload>
        }
        createMany: {
          args: Prisma.UserDataCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserDataCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload>[]
        }
        delete: {
          args: Prisma.UserDataDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload>
        }
        update: {
          args: Prisma.UserDataUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload>
        }
        deleteMany: {
          args: Prisma.UserDataDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserDataUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserDataUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload>[]
        }
        upsert: {
          args: Prisma.UserDataUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDataPayload>
        }
        aggregate: {
          args: Prisma.UserDataAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserData>
        }
        groupBy: {
          args: Prisma.UserDataGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserDataGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserDataCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserDataCountAggregateOutputType> | number
        }
      }
    }
    SensitiveUserData: {
      payload: Prisma.$SensitiveUserDataPayload<ExtArgs>
      fields: Prisma.SensitiveUserDataFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SensitiveUserDataFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SensitiveUserDataPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SensitiveUserDataFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SensitiveUserDataPayload>
        }
        findFirst: {
          args: Prisma.SensitiveUserDataFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SensitiveUserDataPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SensitiveUserDataFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SensitiveUserDataPayload>
        }
        findMany: {
          args: Prisma.SensitiveUserDataFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SensitiveUserDataPayload>[]
        }
        create: {
          args: Prisma.SensitiveUserDataCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SensitiveUserDataPayload>
        }
        createMany: {
          args: Prisma.SensitiveUserDataCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SensitiveUserDataCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SensitiveUserDataPayload>[]
        }
        delete: {
          args: Prisma.SensitiveUserDataDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SensitiveUserDataPayload>
        }
        update: {
          args: Prisma.SensitiveUserDataUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SensitiveUserDataPayload>
        }
        deleteMany: {
          args: Prisma.SensitiveUserDataDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SensitiveUserDataUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SensitiveUserDataUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SensitiveUserDataPayload>[]
        }
        upsert: {
          args: Prisma.SensitiveUserDataUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SensitiveUserDataPayload>
        }
        aggregate: {
          args: Prisma.SensitiveUserDataAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSensitiveUserData>
        }
        groupBy: {
          args: Prisma.SensitiveUserDataGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SensitiveUserDataGroupByOutputType>[]
        }
        count: {
          args: Prisma.SensitiveUserDataCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SensitiveUserDataCountAggregateOutputType> | number
        }
      }
    }
    Invites: {
      payload: Prisma.$InvitesPayload<ExtArgs>
      fields: Prisma.InvitesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvitesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvitesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitesPayload>
        }
        findFirst: {
          args: Prisma.InvitesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvitesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitesPayload>
        }
        findMany: {
          args: Prisma.InvitesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitesPayload>[]
        }
        create: {
          args: Prisma.InvitesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitesPayload>
        }
        createMany: {
          args: Prisma.InvitesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvitesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitesPayload>[]
        }
        delete: {
          args: Prisma.InvitesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitesPayload>
        }
        update: {
          args: Prisma.InvitesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitesPayload>
        }
        deleteMany: {
          args: Prisma.InvitesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvitesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvitesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitesPayload>[]
        }
        upsert: {
          args: Prisma.InvitesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitesPayload>
        }
        aggregate: {
          args: Prisma.InvitesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvites>
        }
        groupBy: {
          args: Prisma.InvitesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvitesGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvitesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvitesCountAggregateOutputType> | number
        }
      }
    }
    VolleyBallTeams: {
      payload: Prisma.$VolleyBallTeamsPayload<ExtArgs>
      fields: Prisma.VolleyBallTeamsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VolleyBallTeamsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolleyBallTeamsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VolleyBallTeamsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolleyBallTeamsPayload>
        }
        findFirst: {
          args: Prisma.VolleyBallTeamsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolleyBallTeamsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VolleyBallTeamsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolleyBallTeamsPayload>
        }
        findMany: {
          args: Prisma.VolleyBallTeamsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolleyBallTeamsPayload>[]
        }
        create: {
          args: Prisma.VolleyBallTeamsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolleyBallTeamsPayload>
        }
        createMany: {
          args: Prisma.VolleyBallTeamsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VolleyBallTeamsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolleyBallTeamsPayload>[]
        }
        delete: {
          args: Prisma.VolleyBallTeamsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolleyBallTeamsPayload>
        }
        update: {
          args: Prisma.VolleyBallTeamsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolleyBallTeamsPayload>
        }
        deleteMany: {
          args: Prisma.VolleyBallTeamsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VolleyBallTeamsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VolleyBallTeamsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolleyBallTeamsPayload>[]
        }
        upsert: {
          args: Prisma.VolleyBallTeamsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolleyBallTeamsPayload>
        }
        aggregate: {
          args: Prisma.VolleyBallTeamsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVolleyBallTeams>
        }
        groupBy: {
          args: Prisma.VolleyBallTeamsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolleyBallTeamsGroupByOutputType>[]
        }
        count: {
          args: Prisma.VolleyBallTeamsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolleyBallTeamsCountAggregateOutputType> | number
        }
      }
    }
    Messages: {
      payload: Prisma.$MessagesPayload<ExtArgs>
      fields: Prisma.MessagesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MessagesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MessagesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagesPayload>
        }
        findFirst: {
          args: Prisma.MessagesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MessagesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagesPayload>
        }
        findMany: {
          args: Prisma.MessagesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagesPayload>[]
        }
        create: {
          args: Prisma.MessagesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagesPayload>
        }
        createMany: {
          args: Prisma.MessagesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MessagesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagesPayload>[]
        }
        delete: {
          args: Prisma.MessagesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagesPayload>
        }
        update: {
          args: Prisma.MessagesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagesPayload>
        }
        deleteMany: {
          args: Prisma.MessagesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MessagesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MessagesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagesPayload>[]
        }
        upsert: {
          args: Prisma.MessagesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagesPayload>
        }
        aggregate: {
          args: Prisma.MessagesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMessages>
        }
        groupBy: {
          args: Prisma.MessagesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessagesGroupByOutputType>[]
        }
        count: {
          args: Prisma.MessagesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessagesCountAggregateOutputType> | number
        }
      }
    }
    ChatGroup: {
      payload: Prisma.$ChatGroupPayload<ExtArgs>
      fields: Prisma.ChatGroupFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ChatGroupFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatGroupPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ChatGroupFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatGroupPayload>
        }
        findFirst: {
          args: Prisma.ChatGroupFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatGroupPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ChatGroupFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatGroupPayload>
        }
        findMany: {
          args: Prisma.ChatGroupFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatGroupPayload>[]
        }
        create: {
          args: Prisma.ChatGroupCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatGroupPayload>
        }
        createMany: {
          args: Prisma.ChatGroupCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ChatGroupCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatGroupPayload>[]
        }
        delete: {
          args: Prisma.ChatGroupDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatGroupPayload>
        }
        update: {
          args: Prisma.ChatGroupUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatGroupPayload>
        }
        deleteMany: {
          args: Prisma.ChatGroupDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ChatGroupUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ChatGroupUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatGroupPayload>[]
        }
        upsert: {
          args: Prisma.ChatGroupUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChatGroupPayload>
        }
        aggregate: {
          args: Prisma.ChatGroupAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateChatGroup>
        }
        groupBy: {
          args: Prisma.ChatGroupGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChatGroupGroupByOutputType>[]
        }
        count: {
          args: Prisma.ChatGroupCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChatGroupCountAggregateOutputType> | number
        }
      }
    }
    PushDeviceTarget: {
      payload: Prisma.$PushDeviceTargetPayload<ExtArgs>
      fields: Prisma.PushDeviceTargetFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PushDeviceTargetFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushDeviceTargetPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PushDeviceTargetFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushDeviceTargetPayload>
        }
        findFirst: {
          args: Prisma.PushDeviceTargetFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushDeviceTargetPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PushDeviceTargetFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushDeviceTargetPayload>
        }
        findMany: {
          args: Prisma.PushDeviceTargetFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushDeviceTargetPayload>[]
        }
        create: {
          args: Prisma.PushDeviceTargetCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushDeviceTargetPayload>
        }
        createMany: {
          args: Prisma.PushDeviceTargetCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PushDeviceTargetCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushDeviceTargetPayload>[]
        }
        delete: {
          args: Prisma.PushDeviceTargetDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushDeviceTargetPayload>
        }
        update: {
          args: Prisma.PushDeviceTargetUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushDeviceTargetPayload>
        }
        deleteMany: {
          args: Prisma.PushDeviceTargetDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PushDeviceTargetUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PushDeviceTargetUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushDeviceTargetPayload>[]
        }
        upsert: {
          args: Prisma.PushDeviceTargetUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PushDeviceTargetPayload>
        }
        aggregate: {
          args: Prisma.PushDeviceTargetAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePushDeviceTarget>
        }
        groupBy: {
          args: Prisma.PushDeviceTargetGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PushDeviceTargetGroupByOutputType>[]
        }
        count: {
          args: Prisma.PushDeviceTargetCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PushDeviceTargetCountAggregateOutputType> | number
        }
      }
    }
    LockFiles: {
      payload: Prisma.$LockFilesPayload<ExtArgs>
      fields: Prisma.LockFilesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LockFilesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LockFilesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LockFilesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LockFilesPayload>
        }
        findFirst: {
          args: Prisma.LockFilesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LockFilesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LockFilesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LockFilesPayload>
        }
        findMany: {
          args: Prisma.LockFilesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LockFilesPayload>[]
        }
        create: {
          args: Prisma.LockFilesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LockFilesPayload>
        }
        createMany: {
          args: Prisma.LockFilesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LockFilesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LockFilesPayload>[]
        }
        delete: {
          args: Prisma.LockFilesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LockFilesPayload>
        }
        update: {
          args: Prisma.LockFilesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LockFilesPayload>
        }
        deleteMany: {
          args: Prisma.LockFilesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LockFilesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LockFilesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LockFilesPayload>[]
        }
        upsert: {
          args: Prisma.LockFilesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LockFilesPayload>
        }
        aggregate: {
          args: Prisma.LockFilesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLockFiles>
        }
        groupBy: {
          args: Prisma.LockFilesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LockFilesGroupByOutputType>[]
        }
        count: {
          args: Prisma.LockFilesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LockFilesCountAggregateOutputType> | number
        }
      }
    }
    PaymentIntents: {
      payload: Prisma.$PaymentIntentsPayload<ExtArgs>
      fields: Prisma.PaymentIntentsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentIntentsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentIntentsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentsPayload>
        }
        findFirst: {
          args: Prisma.PaymentIntentsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentIntentsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentsPayload>
        }
        findMany: {
          args: Prisma.PaymentIntentsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentsPayload>[]
        }
        create: {
          args: Prisma.PaymentIntentsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentsPayload>
        }
        createMany: {
          args: Prisma.PaymentIntentsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentIntentsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentsPayload>[]
        }
        delete: {
          args: Prisma.PaymentIntentsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentsPayload>
        }
        update: {
          args: Prisma.PaymentIntentsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentsPayload>
        }
        deleteMany: {
          args: Prisma.PaymentIntentsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentIntentsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentIntentsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentsPayload>[]
        }
        upsert: {
          args: Prisma.PaymentIntentsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentIntentsPayload>
        }
        aggregate: {
          args: Prisma.PaymentIntentsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentIntents>
        }
        groupBy: {
          args: Prisma.PaymentIntentsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentIntentsGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentIntentsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentIntentsCountAggregateOutputType> | number
        }
      }
    }
    Bills: {
      payload: Prisma.$BillsPayload<ExtArgs>
      fields: Prisma.BillsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BillsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BillsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillsPayload>
        }
        findFirst: {
          args: Prisma.BillsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BillsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillsPayload>
        }
        findMany: {
          args: Prisma.BillsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillsPayload>[]
        }
        create: {
          args: Prisma.BillsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillsPayload>
        }
        createMany: {
          args: Prisma.BillsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BillsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillsPayload>[]
        }
        delete: {
          args: Prisma.BillsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillsPayload>
        }
        update: {
          args: Prisma.BillsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillsPayload>
        }
        deleteMany: {
          args: Prisma.BillsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BillsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BillsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillsPayload>[]
        }
        upsert: {
          args: Prisma.BillsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillsPayload>
        }
        aggregate: {
          args: Prisma.BillsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBills>
        }
        groupBy: {
          args: Prisma.BillsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BillsGroupByOutputType>[]
        }
        count: {
          args: Prisma.BillsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BillsCountAggregateOutputType> | number
        }
      }
    }
    BillPayments: {
      payload: Prisma.$BillPaymentsPayload<ExtArgs>
      fields: Prisma.BillPaymentsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BillPaymentsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillPaymentsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BillPaymentsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillPaymentsPayload>
        }
        findFirst: {
          args: Prisma.BillPaymentsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillPaymentsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BillPaymentsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillPaymentsPayload>
        }
        findMany: {
          args: Prisma.BillPaymentsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillPaymentsPayload>[]
        }
        create: {
          args: Prisma.BillPaymentsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillPaymentsPayload>
        }
        createMany: {
          args: Prisma.BillPaymentsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BillPaymentsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillPaymentsPayload>[]
        }
        delete: {
          args: Prisma.BillPaymentsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillPaymentsPayload>
        }
        update: {
          args: Prisma.BillPaymentsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillPaymentsPayload>
        }
        deleteMany: {
          args: Prisma.BillPaymentsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BillPaymentsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BillPaymentsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillPaymentsPayload>[]
        }
        upsert: {
          args: Prisma.BillPaymentsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BillPaymentsPayload>
        }
        aggregate: {
          args: Prisma.BillPaymentsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBillPayments>
        }
        groupBy: {
          args: Prisma.BillPaymentsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BillPaymentsGroupByOutputType>[]
        }
        count: {
          args: Prisma.BillPaymentsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BillPaymentsCountAggregateOutputType> | number
        }
      }
    }
    RefundRequests: {
      payload: Prisma.$RefundRequestsPayload<ExtArgs>
      fields: Prisma.RefundRequestsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RefundRequestsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundRequestsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RefundRequestsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundRequestsPayload>
        }
        findFirst: {
          args: Prisma.RefundRequestsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundRequestsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RefundRequestsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundRequestsPayload>
        }
        findMany: {
          args: Prisma.RefundRequestsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundRequestsPayload>[]
        }
        create: {
          args: Prisma.RefundRequestsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundRequestsPayload>
        }
        createMany: {
          args: Prisma.RefundRequestsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RefundRequestsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundRequestsPayload>[]
        }
        delete: {
          args: Prisma.RefundRequestsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundRequestsPayload>
        }
        update: {
          args: Prisma.RefundRequestsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundRequestsPayload>
        }
        deleteMany: {
          args: Prisma.RefundRequestsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RefundRequestsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RefundRequestsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundRequestsPayload>[]
        }
        upsert: {
          args: Prisma.RefundRequestsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundRequestsPayload>
        }
        aggregate: {
          args: Prisma.RefundRequestsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRefundRequests>
        }
        groupBy: {
          args: Prisma.RefundRequestsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RefundRequestsGroupByOutputType>[]
        }
        count: {
          args: Prisma.RefundRequestsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RefundRequestsCountAggregateOutputType> | number
        }
      }
    }
    StripeAccounts: {
      payload: Prisma.$StripeAccountsPayload<ExtArgs>
      fields: Prisma.StripeAccountsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StripeAccountsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StripeAccountsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StripeAccountsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StripeAccountsPayload>
        }
        findFirst: {
          args: Prisma.StripeAccountsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StripeAccountsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StripeAccountsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StripeAccountsPayload>
        }
        findMany: {
          args: Prisma.StripeAccountsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StripeAccountsPayload>[]
        }
        create: {
          args: Prisma.StripeAccountsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StripeAccountsPayload>
        }
        createMany: {
          args: Prisma.StripeAccountsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StripeAccountsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StripeAccountsPayload>[]
        }
        delete: {
          args: Prisma.StripeAccountsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StripeAccountsPayload>
        }
        update: {
          args: Prisma.StripeAccountsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StripeAccountsPayload>
        }
        deleteMany: {
          args: Prisma.StripeAccountsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StripeAccountsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StripeAccountsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StripeAccountsPayload>[]
        }
        upsert: {
          args: Prisma.StripeAccountsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StripeAccountsPayload>
        }
        aggregate: {
          args: Prisma.StripeAccountsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStripeAccounts>
        }
        groupBy: {
          args: Prisma.StripeAccountsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StripeAccountsGroupByOutputType>[]
        }
        count: {
          args: Prisma.StripeAccountsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StripeAccountsCountAggregateOutputType> | number
        }
      }
    }
    Events: {
      payload: Prisma.$EventsPayload<ExtArgs>
      fields: Prisma.EventsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload>
        }
        findFirst: {
          args: Prisma.EventsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload>
        }
        findMany: {
          args: Prisma.EventsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload>[]
        }
        create: {
          args: Prisma.EventsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload>
        }
        createMany: {
          args: Prisma.EventsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload>[]
        }
        delete: {
          args: Prisma.EventsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload>
        }
        update: {
          args: Prisma.EventsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload>
        }
        deleteMany: {
          args: Prisma.EventsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload>[]
        }
        upsert: {
          args: Prisma.EventsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventsPayload>
        }
        aggregate: {
          args: Prisma.EventsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEvents>
        }
        groupBy: {
          args: Prisma.EventsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventsGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventsCountAggregateOutputType> | number
        }
      }
    }
    Organizations: {
      payload: Prisma.$OrganizationsPayload<ExtArgs>
      fields: Prisma.OrganizationsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrganizationsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrganizationsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationsPayload>
        }
        findFirst: {
          args: Prisma.OrganizationsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrganizationsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationsPayload>
        }
        findMany: {
          args: Prisma.OrganizationsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationsPayload>[]
        }
        create: {
          args: Prisma.OrganizationsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationsPayload>
        }
        createMany: {
          args: Prisma.OrganizationsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrganizationsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationsPayload>[]
        }
        delete: {
          args: Prisma.OrganizationsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationsPayload>
        }
        update: {
          args: Prisma.OrganizationsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationsPayload>
        }
        deleteMany: {
          args: Prisma.OrganizationsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrganizationsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrganizationsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationsPayload>[]
        }
        upsert: {
          args: Prisma.OrganizationsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationsPayload>
        }
        aggregate: {
          args: Prisma.OrganizationsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganizations>
        }
        groupBy: {
          args: Prisma.OrganizationsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationsGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrganizationsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationsCountAggregateOutputType> | number
        }
      }
    }
    Products: {
      payload: Prisma.$ProductsPayload<ExtArgs>
      fields: Prisma.ProductsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProductsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProductsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductsPayload>
        }
        findFirst: {
          args: Prisma.ProductsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProductsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductsPayload>
        }
        findMany: {
          args: Prisma.ProductsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductsPayload>[]
        }
        create: {
          args: Prisma.ProductsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductsPayload>
        }
        createMany: {
          args: Prisma.ProductsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProductsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductsPayload>[]
        }
        delete: {
          args: Prisma.ProductsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductsPayload>
        }
        update: {
          args: Prisma.ProductsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductsPayload>
        }
        deleteMany: {
          args: Prisma.ProductsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProductsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProductsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductsPayload>[]
        }
        upsert: {
          args: Prisma.ProductsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductsPayload>
        }
        aggregate: {
          args: Prisma.ProductsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProducts>
        }
        groupBy: {
          args: Prisma.ProductsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductsGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProductsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProductsCountAggregateOutputType> | number
        }
      }
    }
    Subscriptions: {
      payload: Prisma.$SubscriptionsPayload<ExtArgs>
      fields: Prisma.SubscriptionsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SubscriptionsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SubscriptionsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
        }
        findFirst: {
          args: Prisma.SubscriptionsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SubscriptionsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
        }
        findMany: {
          args: Prisma.SubscriptionsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionsPayload>[]
        }
        create: {
          args: Prisma.SubscriptionsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
        }
        createMany: {
          args: Prisma.SubscriptionsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SubscriptionsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionsPayload>[]
        }
        delete: {
          args: Prisma.SubscriptionsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
        }
        update: {
          args: Prisma.SubscriptionsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
        }
        deleteMany: {
          args: Prisma.SubscriptionsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SubscriptionsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SubscriptionsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionsPayload>[]
        }
        upsert: {
          args: Prisma.SubscriptionsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
        }
        aggregate: {
          args: Prisma.SubscriptionsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubscriptions>
        }
        groupBy: {
          args: Prisma.SubscriptionsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubscriptionsGroupByOutputType>[]
        }
        count: {
          args: Prisma.SubscriptionsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubscriptionsCountAggregateOutputType> | number
        }
      }
    }
    TimeSlots: {
      payload: Prisma.$TimeSlotsPayload<ExtArgs>
      fields: Prisma.TimeSlotsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TimeSlotsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TimeSlotsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotsPayload>
        }
        findFirst: {
          args: Prisma.TimeSlotsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TimeSlotsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotsPayload>
        }
        findMany: {
          args: Prisma.TimeSlotsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotsPayload>[]
        }
        create: {
          args: Prisma.TimeSlotsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotsPayload>
        }
        createMany: {
          args: Prisma.TimeSlotsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TimeSlotsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotsPayload>[]
        }
        delete: {
          args: Prisma.TimeSlotsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotsPayload>
        }
        update: {
          args: Prisma.TimeSlotsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotsPayload>
        }
        deleteMany: {
          args: Prisma.TimeSlotsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TimeSlotsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TimeSlotsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotsPayload>[]
        }
        upsert: {
          args: Prisma.TimeSlotsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TimeSlotsPayload>
        }
        aggregate: {
          args: Prisma.TimeSlotsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTimeSlots>
        }
        groupBy: {
          args: Prisma.TimeSlotsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TimeSlotsGroupByOutputType>[]
        }
        count: {
          args: Prisma.TimeSlotsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TimeSlotsCountAggregateOutputType> | number
        }
      }
    }
    LeagueScoringConfigs: {
      payload: Prisma.$LeagueScoringConfigsPayload<ExtArgs>
      fields: Prisma.LeagueScoringConfigsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LeagueScoringConfigsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeagueScoringConfigsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LeagueScoringConfigsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeagueScoringConfigsPayload>
        }
        findFirst: {
          args: Prisma.LeagueScoringConfigsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeagueScoringConfigsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LeagueScoringConfigsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeagueScoringConfigsPayload>
        }
        findMany: {
          args: Prisma.LeagueScoringConfigsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeagueScoringConfigsPayload>[]
        }
        create: {
          args: Prisma.LeagueScoringConfigsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeagueScoringConfigsPayload>
        }
        createMany: {
          args: Prisma.LeagueScoringConfigsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LeagueScoringConfigsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeagueScoringConfigsPayload>[]
        }
        delete: {
          args: Prisma.LeagueScoringConfigsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeagueScoringConfigsPayload>
        }
        update: {
          args: Prisma.LeagueScoringConfigsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeagueScoringConfigsPayload>
        }
        deleteMany: {
          args: Prisma.LeagueScoringConfigsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LeagueScoringConfigsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LeagueScoringConfigsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeagueScoringConfigsPayload>[]
        }
        upsert: {
          args: Prisma.LeagueScoringConfigsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeagueScoringConfigsPayload>
        }
        aggregate: {
          args: Prisma.LeagueScoringConfigsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLeagueScoringConfigs>
        }
        groupBy: {
          args: Prisma.LeagueScoringConfigsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeagueScoringConfigsGroupByOutputType>[]
        }
        count: {
          args: Prisma.LeagueScoringConfigsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeagueScoringConfigsCountAggregateOutputType> | number
        }
      }
    }
    Sports: {
      payload: Prisma.$SportsPayload<ExtArgs>
      fields: Prisma.SportsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SportsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SportsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportsPayload>
        }
        findFirst: {
          args: Prisma.SportsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SportsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportsPayload>
        }
        findMany: {
          args: Prisma.SportsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportsPayload>[]
        }
        create: {
          args: Prisma.SportsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportsPayload>
        }
        createMany: {
          args: Prisma.SportsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SportsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportsPayload>[]
        }
        delete: {
          args: Prisma.SportsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportsPayload>
        }
        update: {
          args: Prisma.SportsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportsPayload>
        }
        deleteMany: {
          args: Prisma.SportsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SportsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SportsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportsPayload>[]
        }
        upsert: {
          args: Prisma.SportsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SportsPayload>
        }
        aggregate: {
          args: Prisma.SportsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSports>
        }
        groupBy: {
          args: Prisma.SportsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SportsGroupByOutputType>[]
        }
        count: {
          args: Prisma.SportsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SportsCountAggregateOutputType> | number
        }
      }
    }
    TemplateDocuments: {
      payload: Prisma.$TemplateDocumentsPayload<ExtArgs>
      fields: Prisma.TemplateDocumentsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TemplateDocumentsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplateDocumentsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TemplateDocumentsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplateDocumentsPayload>
        }
        findFirst: {
          args: Prisma.TemplateDocumentsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplateDocumentsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TemplateDocumentsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplateDocumentsPayload>
        }
        findMany: {
          args: Prisma.TemplateDocumentsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplateDocumentsPayload>[]
        }
        create: {
          args: Prisma.TemplateDocumentsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplateDocumentsPayload>
        }
        createMany: {
          args: Prisma.TemplateDocumentsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TemplateDocumentsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplateDocumentsPayload>[]
        }
        delete: {
          args: Prisma.TemplateDocumentsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplateDocumentsPayload>
        }
        update: {
          args: Prisma.TemplateDocumentsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplateDocumentsPayload>
        }
        deleteMany: {
          args: Prisma.TemplateDocumentsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TemplateDocumentsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TemplateDocumentsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplateDocumentsPayload>[]
        }
        upsert: {
          args: Prisma.TemplateDocumentsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TemplateDocumentsPayload>
        }
        aggregate: {
          args: Prisma.TemplateDocumentsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTemplateDocuments>
        }
        groupBy: {
          args: Prisma.TemplateDocumentsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TemplateDocumentsGroupByOutputType>[]
        }
        count: {
          args: Prisma.TemplateDocumentsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TemplateDocumentsCountAggregateOutputType> | number
        }
      }
    }
    SignedDocuments: {
      payload: Prisma.$SignedDocumentsPayload<ExtArgs>
      fields: Prisma.SignedDocumentsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SignedDocumentsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SignedDocumentsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SignedDocumentsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SignedDocumentsPayload>
        }
        findFirst: {
          args: Prisma.SignedDocumentsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SignedDocumentsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SignedDocumentsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SignedDocumentsPayload>
        }
        findMany: {
          args: Prisma.SignedDocumentsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SignedDocumentsPayload>[]
        }
        create: {
          args: Prisma.SignedDocumentsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SignedDocumentsPayload>
        }
        createMany: {
          args: Prisma.SignedDocumentsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SignedDocumentsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SignedDocumentsPayload>[]
        }
        delete: {
          args: Prisma.SignedDocumentsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SignedDocumentsPayload>
        }
        update: {
          args: Prisma.SignedDocumentsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SignedDocumentsPayload>
        }
        deleteMany: {
          args: Prisma.SignedDocumentsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SignedDocumentsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SignedDocumentsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SignedDocumentsPayload>[]
        }
        upsert: {
          args: Prisma.SignedDocumentsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SignedDocumentsPayload>
        }
        aggregate: {
          args: Prisma.SignedDocumentsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSignedDocuments>
        }
        groupBy: {
          args: Prisma.SignedDocumentsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SignedDocumentsGroupByOutputType>[]
        }
        count: {
          args: Prisma.SignedDocumentsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SignedDocumentsCountAggregateOutputType> | number
        }
      }
    }
    ParentChildLinks: {
      payload: Prisma.$ParentChildLinksPayload<ExtArgs>
      fields: Prisma.ParentChildLinksFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ParentChildLinksFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentChildLinksPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ParentChildLinksFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentChildLinksPayload>
        }
        findFirst: {
          args: Prisma.ParentChildLinksFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentChildLinksPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ParentChildLinksFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentChildLinksPayload>
        }
        findMany: {
          args: Prisma.ParentChildLinksFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentChildLinksPayload>[]
        }
        create: {
          args: Prisma.ParentChildLinksCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentChildLinksPayload>
        }
        createMany: {
          args: Prisma.ParentChildLinksCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ParentChildLinksCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentChildLinksPayload>[]
        }
        delete: {
          args: Prisma.ParentChildLinksDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentChildLinksPayload>
        }
        update: {
          args: Prisma.ParentChildLinksUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentChildLinksPayload>
        }
        deleteMany: {
          args: Prisma.ParentChildLinksDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ParentChildLinksUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ParentChildLinksUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentChildLinksPayload>[]
        }
        upsert: {
          args: Prisma.ParentChildLinksUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ParentChildLinksPayload>
        }
        aggregate: {
          args: Prisma.ParentChildLinksAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateParentChildLinks>
        }
        groupBy: {
          args: Prisma.ParentChildLinksGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ParentChildLinksGroupByOutputType>[]
        }
        count: {
          args: Prisma.ParentChildLinksCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ParentChildLinksCountAggregateOutputType> | number
        }
      }
    }
    EventRegistrations: {
      payload: Prisma.$EventRegistrationsPayload<ExtArgs>
      fields: Prisma.EventRegistrationsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventRegistrationsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventRegistrationsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationsPayload>
        }
        findFirst: {
          args: Prisma.EventRegistrationsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventRegistrationsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationsPayload>
        }
        findMany: {
          args: Prisma.EventRegistrationsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationsPayload>[]
        }
        create: {
          args: Prisma.EventRegistrationsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationsPayload>
        }
        createMany: {
          args: Prisma.EventRegistrationsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventRegistrationsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationsPayload>[]
        }
        delete: {
          args: Prisma.EventRegistrationsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationsPayload>
        }
        update: {
          args: Prisma.EventRegistrationsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationsPayload>
        }
        deleteMany: {
          args: Prisma.EventRegistrationsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventRegistrationsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventRegistrationsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationsPayload>[]
        }
        upsert: {
          args: Prisma.EventRegistrationsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationsPayload>
        }
        aggregate: {
          args: Prisma.EventRegistrationsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventRegistrations>
        }
        groupBy: {
          args: Prisma.EventRegistrationsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventRegistrationsGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventRegistrationsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventRegistrationsCountAggregateOutputType> | number
        }
      }
    }
    AuthUser: {
      payload: Prisma.$AuthUserPayload<ExtArgs>
      fields: Prisma.AuthUserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AuthUserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthUserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AuthUserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthUserPayload>
        }
        findFirst: {
          args: Prisma.AuthUserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthUserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AuthUserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthUserPayload>
        }
        findMany: {
          args: Prisma.AuthUserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthUserPayload>[]
        }
        create: {
          args: Prisma.AuthUserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthUserPayload>
        }
        createMany: {
          args: Prisma.AuthUserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AuthUserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthUserPayload>[]
        }
        delete: {
          args: Prisma.AuthUserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthUserPayload>
        }
        update: {
          args: Prisma.AuthUserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthUserPayload>
        }
        deleteMany: {
          args: Prisma.AuthUserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AuthUserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AuthUserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthUserPayload>[]
        }
        upsert: {
          args: Prisma.AuthUserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthUserPayload>
        }
        aggregate: {
          args: Prisma.AuthUserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAuthUser>
        }
        groupBy: {
          args: Prisma.AuthUserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuthUserGroupByOutputType>[]
        }
        count: {
          args: Prisma.AuthUserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuthUserCountAggregateOutputType> | number
        }
      }
    }
    File: {
      payload: Prisma.$FilePayload<ExtArgs>
      fields: Prisma.FileFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FileFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>
        }
        findFirst: {
          args: Prisma.FileFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>
        }
        findMany: {
          args: Prisma.FileFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>[]
        }
        create: {
          args: Prisma.FileCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>
        }
        createMany: {
          args: Prisma.FileCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>[]
        }
        delete: {
          args: Prisma.FileDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>
        }
        update: {
          args: Prisma.FileUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>
        }
        deleteMany: {
          args: Prisma.FileDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FileUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FileUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>[]
        }
        upsert: {
          args: Prisma.FileUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>
        }
        aggregate: {
          args: Prisma.FileAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFile>
        }
        groupBy: {
          args: Prisma.FileGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FileGroupByOutputType>[]
        }
        count: {
          args: Prisma.FileCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FileCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const FieldsScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  fieldNumber: 'fieldNumber',
  divisions: 'divisions',
  lat: 'lat',
  long: 'long',
  heading: 'heading',
  inUse: 'inUse',
  name: 'name',
  type: 'type',
  rentalSlotIds: 'rentalSlotIds',
  location: 'location',
  organizationId: 'organizationId'
} as const

export type FieldsScalarFieldEnum = (typeof FieldsScalarFieldEnum)[keyof typeof FieldsScalarFieldEnum]


export const MatchesScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  start: 'start',
  end: 'end',
  division: 'division',
  team1Points: 'team1Points',
  team2Points: 'team2Points',
  setResults: 'setResults',
  side: 'side',
  matchId: 'matchId',
  losersBracket: 'losersBracket',
  winnerNextMatchId: 'winnerNextMatchId',
  loserNextMatchId: 'loserNextMatchId',
  previousRightId: 'previousRightId',
  previousLeftId: 'previousLeftId',
  refereeCheckedIn: 'refereeCheckedIn',
  refereeId: 'refereeId',
  team1Id: 'team1Id',
  team2Id: 'team2Id',
  eventId: 'eventId',
  fieldId: 'fieldId',
  teamRefereeId: 'teamRefereeId'
} as const

export type MatchesScalarFieldEnum = (typeof MatchesScalarFieldEnum)[keyof typeof MatchesScalarFieldEnum]


export const DivisionsScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  name: 'name',
  key: 'key',
  eventId: 'eventId',
  organizationId: 'organizationId',
  sportId: 'sportId',
  minRating: 'minRating',
  maxRating: 'maxRating',
  fieldIds: 'fieldIds'
} as const

export type DivisionsScalarFieldEnum = (typeof DivisionsScalarFieldEnum)[keyof typeof DivisionsScalarFieldEnum]


export const UserDataScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  firstName: 'firstName',
  lastName: 'lastName',
  dateOfBirth: 'dateOfBirth',
  dobVerified: 'dobVerified',
  dobVerifiedAt: 'dobVerifiedAt',
  ageVerificationProvider: 'ageVerificationProvider',
  teamIds: 'teamIds',
  friendIds: 'friendIds',
  userName: 'userName',
  hasStripeAccount: 'hasStripeAccount',
  followingIds: 'followingIds',
  friendRequestIds: 'friendRequestIds',
  friendRequestSentIds: 'friendRequestSentIds',
  uploadedImages: 'uploadedImages',
  profileImageId: 'profileImageId'
} as const

export type UserDataScalarFieldEnum = (typeof UserDataScalarFieldEnum)[keyof typeof UserDataScalarFieldEnum]


export const SensitiveUserDataScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  userId: 'userId',
  email: 'email'
} as const

export type SensitiveUserDataScalarFieldEnum = (typeof SensitiveUserDataScalarFieldEnum)[keyof typeof SensitiveUserDataScalarFieldEnum]


export const InvitesScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  type: 'type',
  email: 'email',
  status: 'status',
  eventId: 'eventId',
  organizationId: 'organizationId',
  teamId: 'teamId',
  userId: 'userId',
  createdBy: 'createdBy',
  firstName: 'firstName',
  lastName: 'lastName'
} as const

export type InvitesScalarFieldEnum = (typeof InvitesScalarFieldEnum)[keyof typeof InvitesScalarFieldEnum]


export const VolleyBallTeamsScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  seed: 'seed',
  playerIds: 'playerIds',
  division: 'division',
  wins: 'wins',
  losses: 'losses',
  name: 'name',
  captainId: 'captainId',
  pending: 'pending',
  teamSize: 'teamSize',
  profileImageId: 'profileImageId',
  sport: 'sport'
} as const

export type VolleyBallTeamsScalarFieldEnum = (typeof VolleyBallTeamsScalarFieldEnum)[keyof typeof VolleyBallTeamsScalarFieldEnum]


export const MessagesScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  body: 'body',
  userId: 'userId',
  attachmentUrls: 'attachmentUrls',
  chatId: 'chatId',
  readByIds: 'readByIds',
  sentTime: 'sentTime'
} as const

export type MessagesScalarFieldEnum = (typeof MessagesScalarFieldEnum)[keyof typeof MessagesScalarFieldEnum]


export const ChatGroupScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  name: 'name',
  userIds: 'userIds',
  hostId: 'hostId'
} as const

export type ChatGroupScalarFieldEnum = (typeof ChatGroupScalarFieldEnum)[keyof typeof ChatGroupScalarFieldEnum]


export const PushDeviceTargetScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  userId: 'userId',
  pushToken: 'pushToken',
  pushTarget: 'pushTarget',
  pushPlatform: 'pushPlatform',
  lastSeenAt: 'lastSeenAt'
} as const

export type PushDeviceTargetScalarFieldEnum = (typeof PushDeviceTargetScalarFieldEnum)[keyof typeof PushDeviceTargetScalarFieldEnum]


export const LockFilesScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  docId: 'docId',
  expires: 'expires'
} as const

export type LockFilesScalarFieldEnum = (typeof LockFilesScalarFieldEnum)[keyof typeof LockFilesScalarFieldEnum]


export const PaymentIntentsScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  eventId: 'eventId',
  userId: 'userId'
} as const

export type PaymentIntentsScalarFieldEnum = (typeof PaymentIntentsScalarFieldEnum)[keyof typeof PaymentIntentsScalarFieldEnum]


export const BillsScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  ownerType: 'ownerType',
  ownerId: 'ownerId',
  organizationId: 'organizationId',
  eventId: 'eventId',
  totalAmountCents: 'totalAmountCents',
  paidAmountCents: 'paidAmountCents',
  nextPaymentDue: 'nextPaymentDue',
  nextPaymentAmountCents: 'nextPaymentAmountCents',
  parentBillId: 'parentBillId',
  allowSplit: 'allowSplit',
  status: 'status',
  paymentPlanEnabled: 'paymentPlanEnabled',
  createdBy: 'createdBy'
} as const

export type BillsScalarFieldEnum = (typeof BillsScalarFieldEnum)[keyof typeof BillsScalarFieldEnum]


export const BillPaymentsScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  billId: 'billId',
  sequence: 'sequence',
  dueDate: 'dueDate',
  amountCents: 'amountCents',
  status: 'status',
  paidAt: 'paidAt',
  paymentIntentId: 'paymentIntentId',
  payerUserId: 'payerUserId'
} as const

export type BillPaymentsScalarFieldEnum = (typeof BillPaymentsScalarFieldEnum)[keyof typeof BillPaymentsScalarFieldEnum]


export const RefundRequestsScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  eventId: 'eventId',
  userId: 'userId',
  hostId: 'hostId',
  reason: 'reason',
  organizationId: 'organizationId',
  status: 'status'
} as const

export type RefundRequestsScalarFieldEnum = (typeof RefundRequestsScalarFieldEnum)[keyof typeof RefundRequestsScalarFieldEnum]


export const StripeAccountsScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  customerId: 'customerId',
  accountId: 'accountId',
  userId: 'userId',
  organizationId: 'organizationId',
  email: 'email'
} as const

export type StripeAccountsScalarFieldEnum = (typeof StripeAccountsScalarFieldEnum)[keyof typeof StripeAccountsScalarFieldEnum]


export const EventsScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  name: 'name',
  start: 'start',
  end: 'end',
  description: 'description',
  divisions: 'divisions',
  winnerSetCount: 'winnerSetCount',
  loserSetCount: 'loserSetCount',
  doubleElimination: 'doubleElimination',
  location: 'location',
  rating: 'rating',
  teamSizeLimit: 'teamSizeLimit',
  maxParticipants: 'maxParticipants',
  minAge: 'minAge',
  maxAge: 'maxAge',
  hostId: 'hostId',
  price: 'price',
  singleDivision: 'singleDivision',
  waitListIds: 'waitListIds',
  freeAgentIds: 'freeAgentIds',
  cancellationRefundHours: 'cancellationRefundHours',
  teamSignup: 'teamSignup',
  prize: 'prize',
  registrationCutoffHours: 'registrationCutoffHours',
  seedColor: 'seedColor',
  imageId: 'imageId',
  fieldCount: 'fieldCount',
  winnerBracketPointsToVictory: 'winnerBracketPointsToVictory',
  loserBracketPointsToVictory: 'loserBracketPointsToVictory',
  coordinates: 'coordinates',
  gamesPerOpponent: 'gamesPerOpponent',
  includePlayoffs: 'includePlayoffs',
  playoffTeamCount: 'playoffTeamCount',
  usesSets: 'usesSets',
  matchDurationMinutes: 'matchDurationMinutes',
  setDurationMinutes: 'setDurationMinutes',
  setsPerMatch: 'setsPerMatch',
  restTimeMinutes: 'restTimeMinutes',
  state: 'state',
  pointsToVictory: 'pointsToVictory',
  sportId: 'sportId',
  timeSlotIds: 'timeSlotIds',
  fieldIds: 'fieldIds',
  teamIds: 'teamIds',
  userIds: 'userIds',
  registrationIds: 'registrationIds',
  leagueScoringConfigId: 'leagueScoringConfigId',
  organizationId: 'organizationId',
  autoCancellation: 'autoCancellation',
  eventType: 'eventType',
  fieldType: 'fieldType',
  doTeamsRef: 'doTeamsRef',
  refereeIds: 'refereeIds',
  allowPaymentPlans: 'allowPaymentPlans',
  installmentCount: 'installmentCount',
  installmentDueDates: 'installmentDueDates',
  installmentAmounts: 'installmentAmounts',
  allowTeamSplitDefault: 'allowTeamSplitDefault',
  requiredTemplateIds: 'requiredTemplateIds'
} as const

export type EventsScalarFieldEnum = (typeof EventsScalarFieldEnum)[keyof typeof EventsScalarFieldEnum]


export const OrganizationsScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  name: 'name',
  location: 'location',
  description: 'description',
  logoId: 'logoId',
  ownerId: 'ownerId',
  website: 'website',
  refIds: 'refIds',
  hasStripeAccount: 'hasStripeAccount',
  coordinates: 'coordinates',
  fieldIds: 'fieldIds',
  productIds: 'productIds',
  teamIds: 'teamIds'
} as const

export type OrganizationsScalarFieldEnum = (typeof OrganizationsScalarFieldEnum)[keyof typeof OrganizationsScalarFieldEnum]


export const ProductsScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  name: 'name',
  description: 'description',
  priceCents: 'priceCents',
  period: 'period',
  organizationId: 'organizationId',
  createdBy: 'createdBy',
  isActive: 'isActive',
  stripeProductId: 'stripeProductId',
  stripePriceId: 'stripePriceId'
} as const

export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum]


export const SubscriptionsScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  productId: 'productId',
  userId: 'userId',
  organizationId: 'organizationId',
  startDate: 'startDate',
  priceCents: 'priceCents',
  period: 'period',
  status: 'status',
  stripeSubscriptionId: 'stripeSubscriptionId'
} as const

export type SubscriptionsScalarFieldEnum = (typeof SubscriptionsScalarFieldEnum)[keyof typeof SubscriptionsScalarFieldEnum]


export const TimeSlotsScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  dayOfWeek: 'dayOfWeek',
  startTimeMinutes: 'startTimeMinutes',
  endTimeMinutes: 'endTimeMinutes',
  startDate: 'startDate',
  repeating: 'repeating',
  endDate: 'endDate',
  scheduledFieldId: 'scheduledFieldId',
  price: 'price',
  divisions: 'divisions',
  requiredTemplateIds: 'requiredTemplateIds'
} as const

export type TimeSlotsScalarFieldEnum = (typeof TimeSlotsScalarFieldEnum)[keyof typeof TimeSlotsScalarFieldEnum]


export const LeagueScoringConfigsScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  pointsForWin: 'pointsForWin',
  pointsForDraw: 'pointsForDraw',
  pointsForLoss: 'pointsForLoss',
  pointsForForfeitWin: 'pointsForForfeitWin',
  pointsForForfeitLoss: 'pointsForForfeitLoss',
  pointsPerSetWin: 'pointsPerSetWin',
  pointsPerSetLoss: 'pointsPerSetLoss',
  pointsPerGameWin: 'pointsPerGameWin',
  pointsPerGameLoss: 'pointsPerGameLoss',
  pointsPerGoalScored: 'pointsPerGoalScored',
  pointsPerGoalConceded: 'pointsPerGoalConceded',
  maxGoalBonusPoints: 'maxGoalBonusPoints',
  minGoalBonusThreshold: 'minGoalBonusThreshold',
  pointsForShutout: 'pointsForShutout',
  pointsForCleanSheet: 'pointsForCleanSheet',
  applyShutoutOnlyIfWin: 'applyShutoutOnlyIfWin',
  pointsPerGoalDifference: 'pointsPerGoalDifference',
  maxGoalDifferencePoints: 'maxGoalDifferencePoints',
  pointsPenaltyPerGoalDifference: 'pointsPenaltyPerGoalDifference',
  pointsForParticipation: 'pointsForParticipation',
  pointsForNoShow: 'pointsForNoShow',
  pointsForWinStreakBonus: 'pointsForWinStreakBonus',
  winStreakThreshold: 'winStreakThreshold',
  pointsForOvertimeWin: 'pointsForOvertimeWin',
  pointsForOvertimeLoss: 'pointsForOvertimeLoss',
  overtimeEnabled: 'overtimeEnabled',
  pointsPerRedCard: 'pointsPerRedCard',
  pointsPerYellowCard: 'pointsPerYellowCard',
  pointsPerPenalty: 'pointsPerPenalty',
  maxPenaltyDeductions: 'maxPenaltyDeductions',
  maxPointsPerMatch: 'maxPointsPerMatch',
  minPointsPerMatch: 'minPointsPerMatch',
  goalDifferenceTiebreaker: 'goalDifferenceTiebreaker',
  headToHeadTiebreaker: 'headToHeadTiebreaker',
  totalGoalsTiebreaker: 'totalGoalsTiebreaker',
  enableBonusForComebackWin: 'enableBonusForComebackWin',
  bonusPointsForComebackWin: 'bonusPointsForComebackWin',
  enableBonusForHighScoringMatch: 'enableBonusForHighScoringMatch',
  highScoringThreshold: 'highScoringThreshold',
  bonusPointsForHighScoringMatch: 'bonusPointsForHighScoringMatch',
  enablePenaltyForUnsportingBehavior: 'enablePenaltyForUnsportingBehavior',
  penaltyPointsForUnsportingBehavior: 'penaltyPointsForUnsportingBehavior',
  pointPrecision: 'pointPrecision'
} as const

export type LeagueScoringConfigsScalarFieldEnum = (typeof LeagueScoringConfigsScalarFieldEnum)[keyof typeof LeagueScoringConfigsScalarFieldEnum]


export const SportsScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  name: 'name',
  usePointsForWin: 'usePointsForWin',
  usePointsForDraw: 'usePointsForDraw',
  usePointsForLoss: 'usePointsForLoss',
  usePointsForForfeitWin: 'usePointsForForfeitWin',
  usePointsForForfeitLoss: 'usePointsForForfeitLoss',
  usePointsPerSetWin: 'usePointsPerSetWin',
  usePointsPerSetLoss: 'usePointsPerSetLoss',
  usePointsPerGameWin: 'usePointsPerGameWin',
  usePointsPerGameLoss: 'usePointsPerGameLoss',
  usePointsPerGoalScored: 'usePointsPerGoalScored',
  usePointsPerGoalConceded: 'usePointsPerGoalConceded',
  useMaxGoalBonusPoints: 'useMaxGoalBonusPoints',
  useMinGoalBonusThreshold: 'useMinGoalBonusThreshold',
  usePointsForShutout: 'usePointsForShutout',
  usePointsForCleanSheet: 'usePointsForCleanSheet',
  useApplyShutoutOnlyIfWin: 'useApplyShutoutOnlyIfWin',
  usePointsPerGoalDifference: 'usePointsPerGoalDifference',
  useMaxGoalDifferencePoints: 'useMaxGoalDifferencePoints',
  usePointsPenaltyPerGoalDifference: 'usePointsPenaltyPerGoalDifference',
  usePointsForParticipation: 'usePointsForParticipation',
  usePointsForNoShow: 'usePointsForNoShow',
  usePointsForWinStreakBonus: 'usePointsForWinStreakBonus',
  useWinStreakThreshold: 'useWinStreakThreshold',
  usePointsForOvertimeWin: 'usePointsForOvertimeWin',
  usePointsForOvertimeLoss: 'usePointsForOvertimeLoss',
  useOvertimeEnabled: 'useOvertimeEnabled',
  usePointsPerRedCard: 'usePointsPerRedCard',
  usePointsPerYellowCard: 'usePointsPerYellowCard',
  usePointsPerPenalty: 'usePointsPerPenalty',
  useMaxPenaltyDeductions: 'useMaxPenaltyDeductions',
  useMaxPointsPerMatch: 'useMaxPointsPerMatch',
  useMinPointsPerMatch: 'useMinPointsPerMatch',
  useGoalDifferenceTiebreaker: 'useGoalDifferenceTiebreaker',
  useHeadToHeadTiebreaker: 'useHeadToHeadTiebreaker',
  useTotalGoalsTiebreaker: 'useTotalGoalsTiebreaker',
  useEnableBonusForComebackWin: 'useEnableBonusForComebackWin',
  useBonusPointsForComebackWin: 'useBonusPointsForComebackWin',
  useEnableBonusForHighScoringMatch: 'useEnableBonusForHighScoringMatch',
  useHighScoringThreshold: 'useHighScoringThreshold',
  useBonusPointsForHighScoringMatch: 'useBonusPointsForHighScoringMatch',
  useEnablePenaltyUnsporting: 'useEnablePenaltyUnsporting',
  usePenaltyPointsUnsporting: 'usePenaltyPointsUnsporting',
  usePointPrecision: 'usePointPrecision'
} as const

export type SportsScalarFieldEnum = (typeof SportsScalarFieldEnum)[keyof typeof SportsScalarFieldEnum]


export const TemplateDocumentsScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  templateId: 'templateId',
  type: 'type',
  organizationId: 'organizationId',
  title: 'title',
  description: 'description',
  signOnce: 'signOnce',
  requiredSignerType: 'requiredSignerType',
  status: 'status',
  createdBy: 'createdBy',
  roleIndex: 'roleIndex',
  roleIndexes: 'roleIndexes',
  signerRoles: 'signerRoles',
  content: 'content'
} as const

export type TemplateDocumentsScalarFieldEnum = (typeof TemplateDocumentsScalarFieldEnum)[keyof typeof TemplateDocumentsScalarFieldEnum]


export const SignedDocumentsScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  signedDocumentId: 'signedDocumentId',
  templateId: 'templateId',
  userId: 'userId',
  documentName: 'documentName',
  hostId: 'hostId',
  organizationId: 'organizationId',
  eventId: 'eventId',
  status: 'status',
  signedAt: 'signedAt',
  signerEmail: 'signerEmail',
  roleIndex: 'roleIndex',
  signerRole: 'signerRole',
  ipAddress: 'ipAddress',
  requestId: 'requestId'
} as const

export type SignedDocumentsScalarFieldEnum = (typeof SignedDocumentsScalarFieldEnum)[keyof typeof SignedDocumentsScalarFieldEnum]


export const ParentChildLinksScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  parentId: 'parentId',
  childId: 'childId',
  status: 'status',
  relationship: 'relationship',
  linkMethod: 'linkMethod',
  createdBy: 'createdBy',
  endedAt: 'endedAt'
} as const

export type ParentChildLinksScalarFieldEnum = (typeof ParentChildLinksScalarFieldEnum)[keyof typeof ParentChildLinksScalarFieldEnum]


export const EventRegistrationsScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  eventId: 'eventId',
  registrantId: 'registrantId',
  parentId: 'parentId',
  registrantType: 'registrantType',
  status: 'status',
  ageAtEvent: 'ageAtEvent',
  consentDocumentId: 'consentDocumentId',
  consentStatus: 'consentStatus',
  createdBy: 'createdBy'
} as const

export type EventRegistrationsScalarFieldEnum = (typeof EventRegistrationsScalarFieldEnum)[keyof typeof EventRegistrationsScalarFieldEnum]


export const AuthUserScalarFieldEnum = {
  id: 'id',
  email: 'email',
  passwordHash: 'passwordHash',
  name: 'name',
  emailVerifiedAt: 'emailVerifiedAt',
  lastLogin: 'lastLogin',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AuthUserScalarFieldEnum = (typeof AuthUserScalarFieldEnum)[keyof typeof AuthUserScalarFieldEnum]


export const FileScalarFieldEnum = {
  id: 'id',
  uploaderId: 'uploaderId',
  organizationId: 'organizationId',
  bucket: 'bucket',
  originalName: 'originalName',
  mimeType: 'mimeType',
  sizeBytes: 'sizeBytes',
  path: 'path',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'BillsOwnerTypeEnum'
 */
export type EnumBillsOwnerTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillsOwnerTypeEnum'>
    


/**
 * Reference to a field of type 'BillsOwnerTypeEnum[]'
 */
export type ListEnumBillsOwnerTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillsOwnerTypeEnum[]'>
    


/**
 * Reference to a field of type 'BillsStatusEnum'
 */
export type EnumBillsStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillsStatusEnum'>
    


/**
 * Reference to a field of type 'BillsStatusEnum[]'
 */
export type ListEnumBillsStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillsStatusEnum[]'>
    


/**
 * Reference to a field of type 'BillPaymentsStatusEnum'
 */
export type EnumBillPaymentsStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillPaymentsStatusEnum'>
    


/**
 * Reference to a field of type 'BillPaymentsStatusEnum[]'
 */
export type ListEnumBillPaymentsStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillPaymentsStatusEnum[]'>
    


/**
 * Reference to a field of type 'RefundRequestsStatusEnum'
 */
export type EnumRefundRequestsStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundRequestsStatusEnum'>
    


/**
 * Reference to a field of type 'RefundRequestsStatusEnum[]'
 */
export type ListEnumRefundRequestsStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundRequestsStatusEnum[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'EventsStateEnum'
 */
export type EnumEventsStateEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventsStateEnum'>
    


/**
 * Reference to a field of type 'EventsStateEnum[]'
 */
export type ListEnumEventsStateEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventsStateEnum[]'>
    


/**
 * Reference to a field of type 'EventsEventTypeEnum'
 */
export type EnumEventsEventTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventsEventTypeEnum'>
    


/**
 * Reference to a field of type 'EventsEventTypeEnum[]'
 */
export type ListEnumEventsEventTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventsEventTypeEnum[]'>
    


/**
 * Reference to a field of type 'EventsFieldTypeEnum'
 */
export type EnumEventsFieldTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventsFieldTypeEnum'>
    


/**
 * Reference to a field of type 'EventsFieldTypeEnum[]'
 */
export type ListEnumEventsFieldTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventsFieldTypeEnum[]'>
    


/**
 * Reference to a field of type 'ProductsPeriodEnum'
 */
export type EnumProductsPeriodEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductsPeriodEnum'>
    


/**
 * Reference to a field of type 'ProductsPeriodEnum[]'
 */
export type ListEnumProductsPeriodEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductsPeriodEnum[]'>
    


/**
 * Reference to a field of type 'SubscriptionsPeriodEnum'
 */
export type EnumSubscriptionsPeriodEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionsPeriodEnum'>
    


/**
 * Reference to a field of type 'SubscriptionsPeriodEnum[]'
 */
export type ListEnumSubscriptionsPeriodEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionsPeriodEnum[]'>
    


/**
 * Reference to a field of type 'SubscriptionsStatusEnum'
 */
export type EnumSubscriptionsStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionsStatusEnum'>
    


/**
 * Reference to a field of type 'SubscriptionsStatusEnum[]'
 */
export type ListEnumSubscriptionsStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionsStatusEnum[]'>
    


/**
 * Reference to a field of type 'TemplateDocumentsTypeEnum'
 */
export type EnumTemplateDocumentsTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TemplateDocumentsTypeEnum'>
    


/**
 * Reference to a field of type 'TemplateDocumentsTypeEnum[]'
 */
export type ListEnumTemplateDocumentsTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TemplateDocumentsTypeEnum[]'>
    


/**
 * Reference to a field of type 'ParentChildLinksStatusEnum'
 */
export type EnumParentChildLinksStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParentChildLinksStatusEnum'>
    


/**
 * Reference to a field of type 'ParentChildLinksStatusEnum[]'
 */
export type ListEnumParentChildLinksStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParentChildLinksStatusEnum[]'>
    


/**
 * Reference to a field of type 'EventRegistrationsRegistrantTypeEnum'
 */
export type EnumEventRegistrationsRegistrantTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventRegistrationsRegistrantTypeEnum'>
    


/**
 * Reference to a field of type 'EventRegistrationsRegistrantTypeEnum[]'
 */
export type ListEnumEventRegistrationsRegistrantTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventRegistrationsRegistrantTypeEnum[]'>
    


/**
 * Reference to a field of type 'EventRegistrationsStatusEnum'
 */
export type EnumEventRegistrationsStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventRegistrationsStatusEnum'>
    


/**
 * Reference to a field of type 'EventRegistrationsStatusEnum[]'
 */
export type ListEnumEventRegistrationsStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventRegistrationsStatusEnum[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  fields?: Prisma.FieldsOmit
  matches?: Prisma.MatchesOmit
  divisions?: Prisma.DivisionsOmit
  userData?: Prisma.UserDataOmit
  sensitiveUserData?: Prisma.SensitiveUserDataOmit
  invites?: Prisma.InvitesOmit
  volleyBallTeams?: Prisma.VolleyBallTeamsOmit
  messages?: Prisma.MessagesOmit
  chatGroup?: Prisma.ChatGroupOmit
  pushDeviceTarget?: Prisma.PushDeviceTargetOmit
  lockFiles?: Prisma.LockFilesOmit
  paymentIntents?: Prisma.PaymentIntentsOmit
  bills?: Prisma.BillsOmit
  billPayments?: Prisma.BillPaymentsOmit
  refundRequests?: Prisma.RefundRequestsOmit
  stripeAccounts?: Prisma.StripeAccountsOmit
  events?: Prisma.EventsOmit
  organizations?: Prisma.OrganizationsOmit
  products?: Prisma.ProductsOmit
  subscriptions?: Prisma.SubscriptionsOmit
  timeSlots?: Prisma.TimeSlotsOmit
  leagueScoringConfigs?: Prisma.LeagueScoringConfigsOmit
  sports?: Prisma.SportsOmit
  templateDocuments?: Prisma.TemplateDocumentsOmit
  signedDocuments?: Prisma.SignedDocumentsOmit
  parentChildLinks?: Prisma.ParentChildLinksOmit
  eventRegistrations?: Prisma.EventRegistrationsOmit
  authUser?: Prisma.AuthUserOmit
  file?: Prisma.FileOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

